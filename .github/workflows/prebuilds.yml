name: prebuilds
on:
  workflow_call:
    inputs:
      provenance:
        type: boolean
      upload-assets:
        type: boolean

permissions:
  contents: read

jobs:
  unrs-win32-debug:
    runs-on: windows-2022
    strategy:
      fail-fast: false
      matrix:
        arch: [ia32, x64]
        node: [20]
        version: [v1.7.8] # [v1.7.7, v1.7.8, main]
    defaults:
      run:
        shell: bash
    steps:
      - uses: actions/checkout@v4
        with:
          repository: unrs/unrs-resolver
          ref: ${{ matrix.version }}
          persist-credentials: false
      - uses: pnpm/action-setup@v4
      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ matrix.node }}
          cache: pnpm
          architecture: ${{ (matrix.arch == 'ia32' && 'x86') || null }}
      - run: pnpm install
      - run: sed -i 's/default/minimal/' rust-toolchain.toml
      - run: rustup target add i686-pc-windows-msvc
        if: matrix.arch == 'ia32'
      - run: |
          mkdir src/bin
          base64 -d <<@EOF | zstd -d > src/bin/cache_repro.rs
          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
          @EOF
      - run: cargo run --release --bin cache_repro
      - run: |
          patch -p1 <<EOF
          diff --git a/src/fs_cache.rs b/src/fs_cache.rs
          index aadddf7..0a97ad0 100644
          --- a/src/fs_cache.rs
          +++ b/src/fs_cache.rs
          @@ -48,6 +48,7 @@ impl<Fs: FileSystem> Cache for FsCache<Fs> {
               type Tc = TsConfigSerde;

               fn clear(&self) {
          +        println!("TRACE: pin/clear");
                   self.paths.pin().clear();
                   self.tsconfigs.pin().clear();
               }
          @@ -62,16 +63,23 @@ impl<Fs: FileSystem> Cache for FsCache<Fs> {
                       hasher.finish()
                   };
                   let paths = self.paths.pin();
          +        println!("TRACE: enter pin");
          +        let get_key = BorrowedCachedPath { hash, path };
          +        println!("TRACE: get({get_key:?})");
                   if let Some(entry) = paths.get(&BorrowedCachedPath { hash, path }) {
          +            println!("TRACE: -> hit");
                       return entry.clone();
                   }
          +        println!("TRACE: -> miss");
                   let parent = path.parent().map(|p| self.value(p));
                   let cached_path = FsCachedPath(Arc::new(CachedPathImpl::new(
                       hash,
                       path.to_path_buf().into_boxed_path(),
                       parent,
                   )));
          +        println!("TRACE: insert(FsCachedPath {{ hash: {}, path: {:?}, .. }})", cached_path.hash, cached_path.path);
                   paths.insert(cached_path.clone());
          +        println!("TRACE: exit pin");
                   cached_path
               }

          @@ -215,6 +223,7 @@ impl<Fs: FileSystem> FsCache<Fs> {
               ///
               /// <https://github.com/parcel-bundler/parcel/blob/4d27ec8b8bd1792f536811fef86e74a31fa0e704/crates/parcel-resolver/src/cache.rs#L232>
               fn canonicalize_impl(&self, path: &FsCachedPath) -> Result<FsCachedPath, ResolveError> {
          +        println!("canonicalize_impl(path={:?})", path.path);
                   // Check if this thread is already canonicalizing. If so, we have found a circular symlink.
                   // If a different thread is canonicalizing, OnceLock will queue this thread to wait for the result.
                   let tid = THREAD_ID.with(|t| *t);
          @@ -222,20 +231,28 @@ impl<Fs: FileSystem> FsCache<Fs> {
                       return Err(io::Error::new(io::ErrorKind::NotFound, "Circular symlink").into());
                   }

          -        path.canonicalized
          +        println!("  already inited={}", path.canonicalized.get().is_some());
          +        let res = path.canonicalized
                       .get_or_init(|| {
                           path.canonicalizing.store(tid, Ordering::Release);

                           let res = path.parent().map_or_else(
          -                    || Ok(path.normalize_root(self)),
          +                    || {
          +                        println!("  calling normalize_root");
          +                        Ok(path.normalize_root(self))
          +                    },
                               |parent| {
          +                        println!("  canonicalizing parent");
                                   self.canonicalize_impl(parent).and_then(|parent_canonical| {
          +                            println!("  parent_canonical.path={:?}", parent_canonical.path);
                                       let normalized = parent_canonical.normalize_with(
                                           path.path().strip_prefix(parent.path()).unwrap(),
                                           self,
                                       );
          +                            println!("  normalized.path={:?}", normalized.path);

                                       if self.fs.symlink_metadata(path.path()).is_ok_and(|m| m.is_symlink) {
          +                                println!("  path is symlink");
                                           match self.fs.read_link(normalized.path()) {
                                               Ok(link) => {
                                                   if link.is_absolute() {
          @@ -264,6 +281,8 @@ impl<Fs: FileSystem> FsCache<Fs> {
                                               }
                                               Err(e) => return Err(e),
                                           }
          +                            } else {
          +                                println!("  path is not symlink");
                                       }

                                       Ok(normalized)
          @@ -273,8 +292,11 @@ impl<Fs: FileSystem> FsCache<Fs> {

                           path.canonicalizing.store(0, Ordering::Release);
                           res
          -            })
          -            .clone()
          +            });
          +        println!("  get_or_init returned is_ok={}", res.is_ok());
          +        let res_cloned = res.clone();
          +        println!("clone returned");
          +        return res_cloned;
               }
           }

          @@ -475,6 +497,7 @@ impl PartialEq for FsCachedPath {

           impl Eq for FsCachedPath {}

          +#[derive(Debug)]
           struct BorrowedCachedPath<'a> {
               hash: u64,
               path: &'a Path,
          diff --git a/src/lib.rs b/src/lib.rs
          index 91ab331..c8529e0 100644
          --- a/src/lib.rs
          +++ b/src/lib.rs
          @@ -277,16 +277,29 @@ impl<C: Cache<Cp = FsCachedPath>> ResolverGeneric<C> {
                   specifier: &str,
                   ctx: &mut Ctx,
               ) -> Result<Resolution<C>, ResolveError> {
          +        println!("resolve_impl({path:?}, {specifier:?}, {ctx:#?})");
                   ctx.with_fully_specified(self.options.fully_specified);

                   let cached_path = if self.options.symlinks {
          -            self.load_realpath(&self.cache.value(path))?
          +            println!("in symlink branch, calling cache.value({path:?})");
          +            let cache_res = self.cache.value(path);
          +            println!("in symlink branch, calling load_realpath(...)");
          +            self.load_realpath(&cache_res)?
                   } else {
                       path.to_path_buf()
                   };

          +        println!("calling cache.value({cached_path:?})");
                   let cached_path = self.cache.value(&cached_path);
          -        let cached_path = self.require(&cached_path, specifier, ctx)?;
          +        println!("calling self.require(...)");
          +        let cached_path = match self.require(&cached_path, specifier, ctx) {
          +            Ok(v) => v,
          +            Err(e) => {
          +                println!("require failed with {e:?}");
          +                return Err(e);
          +            }
          +        };
          +        println!("require succeeded");

                   let path = if self.options.symlinks {
                       self.load_realpath(&cached_path)?
          EOF
      - run: pnpm run build --target="${RUST_ARCH}-pc-windows-msvc"
        env:
          CARGO_PROFILE_RELEASE_DEBUG_ASSERTIONS: 'true'
          CARGO_PROFILE_RELEASE_OVERFLOW_CHECKS: 'true'
          CARGO_PROFILE_RELEASE_PANIC: unwind
          RUST_ARCH: ${{ (matrix.arch == 'ia32' && 'i686') || 'x86_64' }}
      - run: |
          cat >repro.js <<EOF
          const {ResolverFactory} = require('./napi');
          let resolver = new ResolverFactory({});
          resolver.sync(__dirname, 'x-' + __dirname + '\\\\node_modules\\\\any.js');
          resolver = resolver.cloneWithOptions({});
          resolver.clearCache();
          resolver.sync(__dirname + '\\\\node_modules\\\\foo-bar-foo-bar-fo', 'foo-bar-fo');
          console.log('unexpectedly survived second sync call');
          EOF

      - run: node repro.js
      # - run: pnpm run test
      # - run: for i in {0..100}; do node unrs_repro.js; done
