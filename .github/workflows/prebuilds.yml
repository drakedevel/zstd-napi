name: prebuilds
on:
  workflow_call:
    inputs:
      provenance:
        type: boolean
      upload-assets:
        type: boolean

permissions:
  contents: read

jobs:
  unrs-win32-debug:
    runs-on: windows-2022
    strategy:
      fail-fast: false
      matrix:
        arch: [ia32, x64]
        node: [20]
        version: [v1.7.8] # [v1.7.7, v1.7.8, main]
    defaults:
      run:
        shell: bash
    steps:
      - uses: actions/checkout@v4
        with:
          repository: unrs/unrs-resolver
          ref: ${{ matrix.version }}
          persist-credentials: false
      - uses: pnpm/action-setup@v4
      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ matrix.node }}
          cache: pnpm
          architecture: ${{ (matrix.arch == 'ia32' && 'x86') || null }}
      - run: pnpm install
      - run: sed -i 's/default/minimal/' rust-toolchain.toml
      - run: rustup target add i686-pc-windows-msvc
        if: matrix.arch == 'ia32'
      - run: |
          patch -p1 <<EOF
          diff --git a/src/fs_cache.rs b/src/fs_cache.rs
          index aadddf7..e2e4a86 100644
          --- a/src/fs_cache.rs
          +++ b/src/fs_cache.rs
          @@ -62,6 +62,7 @@ impl<Fs: FileSystem> Cache for FsCache<Fs> {
                       hasher.finish()
                   };
                   let paths = self.paths.pin();
          +        println!("performing lookup hash={hash} path={path:?}");
                   if let Some(entry) = paths.get(&BorrowedCachedPath { hash, path }) {
                       return entry.clone();
                   }
          @@ -215,6 +216,7 @@ impl<Fs: FileSystem> FsCache<Fs> {
               ///
               /// <https://github.com/parcel-bundler/parcel/blob/4d27ec8b8bd1792f536811fef86e74a31fa0e704/crates/parcel-resolver/src/cache.rs#L232>
               fn canonicalize_impl(&self, path: &FsCachedPath) -> Result<FsCachedPath, ResolveError> {
          +        println!("canonicalize_impl(path={:?})", path.path);
                   // Check if this thread is already canonicalizing. If so, we have found a circular symlink.
                   // If a different thread is canonicalizing, OnceLock will queue this thread to wait for the result.
                   let tid = THREAD_ID.with(|t| *t);
          @@ -222,20 +224,28 @@ impl<Fs: FileSystem> FsCache<Fs> {
                       return Err(io::Error::new(io::ErrorKind::NotFound, "Circular symlink").into());
                   }

          -        path.canonicalized
          +        println!("  already inited={}", path.canonicalized.get().is_some());
          +        let res = path.canonicalized
                       .get_or_init(|| {
                           path.canonicalizing.store(tid, Ordering::Release);

                           let res = path.parent().map_or_else(
          -                    || Ok(path.normalize_root(self)),
          +                    || {
          +                        println!("  calling normalize_root");
          +                        Ok(path.normalize_root(self))
          +                    },
                               |parent| {
          +                        println!("  canonicalizing parent");
                                   self.canonicalize_impl(parent).and_then(|parent_canonical| {
          +                            println!("  parent_canonical.path={:?}", parent_canonical.path);
                                       let normalized = parent_canonical.normalize_with(
                                           path.path().strip_prefix(parent.path()).unwrap(),
                                           self,
                                       );
          +                            println!("  normalized.path={:?}", normalized.path);

                                       if self.fs.symlink_metadata(path.path()).is_ok_and(|m| m.is_symlink) {
          +                                println!("  path is symlink");
                                           match self.fs.read_link(normalized.path()) {
                                               Ok(link) => {
                                                   if link.is_absolute() {
          @@ -264,6 +274,8 @@ impl<Fs: FileSystem> FsCache<Fs> {
                                               }
                                               Err(e) => return Err(e),
                                           }
          +                            } else {
          +                                println!("  path is not symlink");
                                       }

                                       Ok(normalized)
          @@ -273,8 +285,11 @@ impl<Fs: FileSystem> FsCache<Fs> {

                           path.canonicalizing.store(0, Ordering::Release);
                           res
          -            })
          -            .clone()
          +            });
          +        println!("  get_or_init returned is_ok={}", res.is_ok());
          +        let res_cloned = res.clone();
          +        println!("clone returned");
          +        return res_cloned;
               }
           }

          diff --git a/src/lib.rs b/src/lib.rs
          index 91ab331..c8529e0 100644
          --- a/src/lib.rs
          +++ b/src/lib.rs
          @@ -277,16 +277,29 @@ impl<C: Cache<Cp = FsCachedPath>> ResolverGeneric<C> {
                   specifier: &str,
                   ctx: &mut Ctx,
               ) -> Result<Resolution<C>, ResolveError> {
          +        println!("resolve_impl({path:?}, {specifier:?}, {ctx:#?})");
                   ctx.with_fully_specified(self.options.fully_specified);

                   let cached_path = if self.options.symlinks {
          -            self.load_realpath(&self.cache.value(path))?
          +            println!("in symlink branch, calling cache.value({path:?})");
          +            let cache_res = self.cache.value(path);
          +            println!("in symlink branch, calling load_realpath(...)");
          +            self.load_realpath(&cache_res)?
                   } else {
                       path.to_path_buf()
                   };

          +        println!("calling cache.value({cached_path:?})");
                   let cached_path = self.cache.value(&cached_path);
          -        let cached_path = self.require(&cached_path, specifier, ctx)?;
          +        println!("calling self.require(...)");
          +        let cached_path = match self.require(&cached_path, specifier, ctx) {
          +            Ok(v) => v,
          +            Err(e) => {
          +                println!("require failed with {e:?}");
          +                return Err(e);
          +            }
          +        };
          +        println!("require succeeded");

                   let path = if self.options.symlinks {
                       self.load_realpath(&cached_path)?
          EOF
      - run: pnpm run build --target="${RUST_ARCH}-pc-windows-msvc"
        env:
          CARGO_PROFILE_RELEASE_DEBUG_ASSERTIONS: 'true'
          CARGO_PROFILE_RELEASE_OVERFLOW_CHECKS: 'true'
          CARGO_PROFILE_RELEASE_PANIC: unwind
          RUST_ARCH: ${{ (matrix.arch == 'ia32' && 'i686') || 'x86_64' }}
      - run: |
          cat >repro.js <<EOF
          const {ResolverFactory} = require('./napi');
          let resolver = new ResolverFactory({});
          resolver.sync(__dirname, 'x-' + __dirname + '\\\\node_modules\\\\any.js');
          resolver = resolver.cloneWithOptions({});
          resolver.clearCache();
          resolver.sync(__dirname + '\\\\node_modules\\\\foo-bar-foo-bar-fo', 'foo-bar-fo');
          console.log('unexpectedly survived second sync call');
          EOF

      - run: node repro.js
      # - run: pnpm run test
      # - run: for i in {0..100}; do node unrs_repro.js; done
