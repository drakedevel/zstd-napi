name: prebuilds
on:
  workflow_call:
    inputs:
      provenance:
        type: boolean
      upload-assets:
        type: boolean

permissions:
  contents: read

jobs:
  unrs-win32-debug:
    runs-on: windows-2022
    strategy:
      fail-fast: false
      matrix:
        arch: [ia32, x64]
        node: [20]
        version: [v1.7.8] # [v1.7.7, v1.7.8, main]
    defaults:
      run:
        shell: bash
    steps:
      - uses: actions/checkout@v4
        with:
          repository: unrs/unrs-resolver
          ref: ${{ matrix.version }}
          persist-credentials: false
      - uses: pnpm/action-setup@v4
      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ matrix.node }}
          cache: pnpm
          architecture: ${{ (matrix.arch == 'ia32' && 'x86') || null }}
      - run: pnpm install
      - run: sed -i 's/default/minimal/' rust-toolchain.toml
      - run: rustup target add i686-pc-windows-msvc
        if: matrix.arch == 'ia32'
      - run: |
          mkdir src/bin
          base64 -d <<@EOF | zstd -d > src/bin/cache_repro.rs
          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
          @EOF
      - run: cargo run --release --bin cache_repro
      - run: |
          patch -p1 <<EOF
          diff --git a/src/fs_cache.rs b/src/fs_cache.rs
          index aadddf7..0a97ad0 100644
          --- a/src/fs_cache.rs
          +++ b/src/fs_cache.rs
          @@ -48,6 +48,7 @@ impl<Fs: FileSystem> Cache for FsCache<Fs> {
               type Tc = TsConfigSerde;

               fn clear(&self) {
          +        println!("TRACE: pin/clear");
                   self.paths.pin().clear();
                   self.tsconfigs.pin().clear();
               }
          @@ -62,16 +63,23 @@ impl<Fs: FileSystem> Cache for FsCache<Fs> {
                       hasher.finish()
                   };
                   let paths = self.paths.pin();
          +        println!("TRACE: enter pin");
          +        let get_key = BorrowedCachedPath { hash, path };
          +        println!("TRACE: get({get_key:?})");
                   if let Some(entry) = paths.get(&BorrowedCachedPath { hash, path }) {
          +            println!("TRACE: -> hit");
                       return entry.clone();
                   }
          +        println!("TRACE: -> miss");
                   let parent = path.parent().map(|p| self.value(p));
                   let cached_path = FsCachedPath(Arc::new(CachedPathImpl::new(
                       hash,
                       path.to_path_buf().into_boxed_path(),
                       parent,
                   )));
          +        println!("TRACE: insert(FsCachedPath {{ hash: {}, path: {:?}, .. }})", cached_path.hash, cached_path.path);
                   paths.insert(cached_path.clone());
          +        println!("TRACE: exit pin");
                   cached_path
               }

          @@ -215,6 +223,7 @@ impl<Fs: FileSystem> FsCache<Fs> {
               ///
               /// <https://github.com/parcel-bundler/parcel/blob/4d27ec8b8bd1792f536811fef86e74a31fa0e704/crates/parcel-resolver/src/cache.rs#L232>
               fn canonicalize_impl(&self, path: &FsCachedPath) -> Result<FsCachedPath, ResolveError> {
          +        println!("canonicalize_impl(path={:?})", path.path);
                   // Check if this thread is already canonicalizing. If so, we have found a circular symlink.
                   // If a different thread is canonicalizing, OnceLock will queue this thread to wait for the result.
                   let tid = THREAD_ID.with(|t| *t);
          @@ -222,20 +231,28 @@ impl<Fs: FileSystem> FsCache<Fs> {
                       return Err(io::Error::new(io::ErrorKind::NotFound, "Circular symlink").into());
                   }

          -        path.canonicalized
          +        println!("  already inited={}", path.canonicalized.get().is_some());
          +        let res = path.canonicalized
                       .get_or_init(|| {
                           path.canonicalizing.store(tid, Ordering::Release);

                           let res = path.parent().map_or_else(
          -                    || Ok(path.normalize_root(self)),
          +                    || {
          +                        println!("  calling normalize_root");
          +                        Ok(path.normalize_root(self))
          +                    },
                               |parent| {
          +                        println!("  canonicalizing parent");
                                   self.canonicalize_impl(parent).and_then(|parent_canonical| {
          +                            println!("  parent_canonical.path={:?}", parent_canonical.path);
                                       let normalized = parent_canonical.normalize_with(
                                           path.path().strip_prefix(parent.path()).unwrap(),
                                           self,
                                       );
          +                            println!("  normalized.path={:?}", normalized.path);

                                       if self.fs.symlink_metadata(path.path()).is_ok_and(|m| m.is_symlink) {
          +                                println!("  path is symlink");
                                           match self.fs.read_link(normalized.path()) {
                                               Ok(link) => {
                                                   if link.is_absolute() {
          @@ -264,6 +281,8 @@ impl<Fs: FileSystem> FsCache<Fs> {
                                               }
                                               Err(e) => return Err(e),
                                           }
          +                            } else {
          +                                println!("  path is not symlink");
                                       }

                                       Ok(normalized)
          @@ -273,8 +292,11 @@ impl<Fs: FileSystem> FsCache<Fs> {

                           path.canonicalizing.store(0, Ordering::Release);
                           res
          -            })
          -            .clone()
          +            });
          +        println!("  get_or_init returned is_ok={}", res.is_ok());
          +        let res_cloned = res.clone();
          +        println!("clone returned");
          +        return res_cloned;
               }
           }

          @@ -475,6 +497,7 @@ impl PartialEq for FsCachedPath {

           impl Eq for FsCachedPath {}

          +#[derive(Debug)]
           struct BorrowedCachedPath<'a> {
               hash: u64,
               path: &'a Path,
          diff --git a/src/lib.rs b/src/lib.rs
          index 91ab331..c8529e0 100644
          --- a/src/lib.rs
          +++ b/src/lib.rs
          @@ -277,16 +277,29 @@ impl<C: Cache<Cp = FsCachedPath>> ResolverGeneric<C> {
                   specifier: &str,
                   ctx: &mut Ctx,
               ) -> Result<Resolution<C>, ResolveError> {
          +        println!("resolve_impl({path:?}, {specifier:?}, {ctx:#?})");
                   ctx.with_fully_specified(self.options.fully_specified);

                   let cached_path = if self.options.symlinks {
          -            self.load_realpath(&self.cache.value(path))?
          +            println!("in symlink branch, calling cache.value({path:?})");
          +            let cache_res = self.cache.value(path);
          +            println!("in symlink branch, calling load_realpath(...)");
          +            self.load_realpath(&cache_res)?
                   } else {
                       path.to_path_buf()
                   };

          +        println!("calling cache.value({cached_path:?})");
                   let cached_path = self.cache.value(&cached_path);
          -        let cached_path = self.require(&cached_path, specifier, ctx)?;
          +        println!("calling self.require(...)");
          +        let cached_path = match self.require(&cached_path, specifier, ctx) {
          +            Ok(v) => v,
          +            Err(e) => {
          +                println!("require failed with {e:?}");
          +                return Err(e);
          +            }
          +        };
          +        println!("require succeeded");

                   let path = if self.options.symlinks {
                       self.load_realpath(&cached_path)?
          EOF
      - run: pnpm run build --target="${RUST_ARCH}-pc-windows-msvc"
        env:
          CARGO_PROFILE_RELEASE_DEBUG_ASSERTIONS: 'true'
          CARGO_PROFILE_RELEASE_OVERFLOW_CHECKS: 'true'
          CARGO_PROFILE_RELEASE_PANIC: unwind
          RUST_ARCH: ${{ (matrix.arch == 'ia32' && 'i686') || 'x86_64' }}
      - run: |
          cat >repro.js <<EOF
          const {ResolverFactory} = require('./napi');
          let resolver = new ResolverFactory({});
          resolver.sync(__dirname, 'x-' + __dirname + '\\\\node_modules\\\\any.js');
          resolver = resolver.cloneWithOptions({});
          resolver.clearCache();
          resolver.sync(__dirname + '\\\\node_modules\\\\foo-bar-foo-bar-fo', 'foo-bar-fo');
          console.log('unexpectedly survived second sync call');
          EOF

      - run: node repro.js
      # - run: pnpm run test
      # - run: for i in {0..100}; do node unrs_repro.js; done
