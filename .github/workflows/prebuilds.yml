name: prebuilds
on:
  workflow_call:
    inputs:
      provenance:
        type: boolean
      upload-assets:
        type: boolean

permissions:
  contents: read

jobs:
  unrs-win32-debug:
    runs-on: windows-2022
    strategy:
      fail-fast: false
      matrix:
        arch: [ia32, x64]
        node: [20]
        version: [v1.7.8] # [v1.7.7, v1.7.8, main]
    defaults:
      run:
        shell: bash
    steps:
      - uses: actions/checkout@v4
        with:
          repository: unrs/unrs-resolver
          ref: ${{ matrix.version }}
          persist-credentials: false
      - uses: pnpm/action-setup@v4
      - uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4.4.0
        with:
          node-version: ${{ matrix.node }}
          cache: pnpm
          architecture: ${{ (matrix.arch == 'ia32' && 'x86') || null }}
      - run: pnpm install
      - run: sed -i 's/default/minimal/' rust-toolchain.toml
      - run: rustup target add i686-pc-windows-msvc
        if: matrix.arch == 'ia32'
      # - run: |
      #     mkdir src/bin
      #     base64 -d <<@EOF | zstd -d > src/bin/cache_repro.rs
      #     @EOF
      # - run: cargo run --release --bin cache_repro
      - run: echo "$PATCH_BODY" | patch -p1
        env:
          PATCH_BODY: |
            diff --git a/src/fs_cache.rs b/src/fs_cache.rs
            index aadddf7..b7d3d79 100644
            --- a/src/fs_cache.rs
            +++ b/src/fs_cache.rs
            @@ -24,6 +24,7 @@ use crate::{
                 context::ResolveContext as Ctx,
                 path::PathUtil,
             };
            +use std::time::Instant;

             static THREAD_COUNT: AtomicU64 = AtomicU64::new(1);

            @@ -35,11 +36,28 @@ thread_local! {
             }

             /// Cache implementation used for caching filesystem access.
            -#[derive(Default)]
             pub struct FsCache<Fs> {
                 pub(crate) fs: Fs,
                 paths: HashSet<FsCachedPath, BuildHasherDefault<IdentityHasher>>,
                 tsconfigs: HashMap<PathBuf, Arc<TsConfigSerde>, BuildHasherDefault<FxHasher>>,
            +    epoch: Instant,
            +}
            +
            +impl<Fs: Default> Default for FsCache<Fs> {
            +    fn default() -> Self {
            +        Self {
            +            fs: Default::default(),
            +            paths: Default::default(),
            +            tsconfigs: Default::default(),
            +            epoch: Instant::now(),
            +        }
            +    }
            +}
            +
            +impl<Fs> FsCache<Fs> {
            +    fn ts(&self) -> u128 {
            +        self.epoch.elapsed().as_micros()
            +    }
             }

             impl<Fs: FileSystem> Cache for FsCache<Fs> {
            @@ -48,6 +66,7 @@ impl<Fs: FileSystem> Cache for FsCache<Fs> {
                 type Tc = TsConfigSerde;

                 fn clear(&self) {
            +        println!("TRACE:{}: pin/clear", self.ts());
                     self.paths.pin().clear();
                     self.tsconfigs.pin().clear();
                 }
            @@ -62,16 +81,42 @@ impl<Fs: FileSystem> Cache for FsCache<Fs> {
                         hasher.finish()
                     };
                     let paths = self.paths.pin();
            +        println!("TRACE:{}: enter pin (tid={:?})", self.ts(), std::thread::current().id());
            +        let get_key = BorrowedCachedPath { hash, path };
            +        println!("TRACE:{}: get({get_key:?})", self.ts());
                     if let Some(entry) = paths.get(&BorrowedCachedPath { hash, path }) {
            +            println!("TRACE:{}: -> hit", self.ts());
                         return entry.clone();
                     }
            +        println!("TRACE:{}: -> miss", self.ts());
            +        for entry in paths.iter() {
            +            println!("TRACE:{}: entry hash={} path={:?} ({:?})", self.ts(), entry.hash, entry.path, entry.path.as_ref() as *const Path);
            +        }
                     let parent = path.parent().map(|p| self.value(p));
                     let cached_path = FsCachedPath(Arc::new(CachedPathImpl::new(
                         hash,
                         path.to_path_buf().into_boxed_path(),
                         parent,
                     )));
            -        paths.insert(cached_path.clone());
            +        println!(
            +            "TRACE:{}: insert(FsCachedPath {{ hash: {}, path: {:?}, .. }})",
            +            self.ts(), cached_path.hash, cached_path.path,
            +        );
            +        let insert_res = paths.insert(cached_path.clone());
            +        println!("TRACE:{}: -> inserted={insert_res}", self.ts());
            +        if insert_res {
            +            assert!(BorrowedCachedPath { hash, path }.equivalent(&cached_path));
            +            assert!(cached_path.eq(&cached_path));
            +            let bugged = paths.get(&BorrowedCachedPath { hash, path }).is_none();
            +            if bugged {
            +                println!("TRACE:{}: BUGGED", self.ts());
            +                for entry in paths.iter() {
            +                    println!("TRACE:{}: entry hash={} path={:?} ({:?}) equiv={}", self.ts(), entry.hash, entry.path, entry.path.as_ref() as *const Path, entry.equivalent(&cached_path));
            +                }
            +                panic!("Inserted record couldn't be retrieved!");
            +            }
            +        }
            +        println!("TRACE:{}: exit pin", self.ts());
                     cached_path
                 }

            @@ -208,6 +253,7 @@ impl<Fs: FileSystem> FsCache<Fs> {
                             .hasher(BuildHasherDefault::default())
                             .resize_mode(papaya::ResizeMode::Blocking)
                             .build(),
            +            epoch: Instant::now(),
                     }
                 }

            @@ -215,6 +261,7 @@ impl<Fs: FileSystem> FsCache<Fs> {
                 ///
                 /// <https://github.com/parcel-bundler/parcel/blob/4d27ec8b8bd1792f536811fef86e74a31fa0e704/crates/parcel-resolver/src/cache.rs#L232>
                 fn canonicalize_impl(&self, path: &FsCachedPath) -> Result<FsCachedPath, ResolveError> {
            +        println!("canonicalize_impl(path={:?})", path.path);
                     // Check if this thread is already canonicalizing. If so, we have found a circular symlink.
                     // If a different thread is canonicalizing, OnceLock will queue this thread to wait for the result.
                     let tid = THREAD_ID.with(|t| *t);
            @@ -222,59 +269,68 @@ impl<Fs: FileSystem> FsCache<Fs> {
                         return Err(io::Error::new(io::ErrorKind::NotFound, "Circular symlink").into());
                     }

            -        path.canonicalized
            -            .get_or_init(|| {
            -                path.canonicalizing.store(tid, Ordering::Release);
            -
            -                let res = path.parent().map_or_else(
            -                    || Ok(path.normalize_root(self)),
            -                    |parent| {
            -                        self.canonicalize_impl(parent).and_then(|parent_canonical| {
            -                            let normalized = parent_canonical.normalize_with(
            -                                path.path().strip_prefix(parent.path()).unwrap(),
            -                                self,
            -                            );
            -
            -                            if self.fs.symlink_metadata(path.path()).is_ok_and(|m| m.is_symlink) {
            -                                match self.fs.read_link(normalized.path()) {
            -                                    Ok(link) => {
            -                                        if link.is_absolute() {
            -                                            return self
            -                                                .canonicalize_impl(&self.value(&link.normalize()));
            -                                        } else if let Some(dir) = normalized.parent() {
            -                                            // Symlink is relative `../../foo.js`, use the path directory
            -                                            // to resolve this symlink.
            -                                            return self.canonicalize_impl(
            -                                                &dir.normalize_with(&link, self),
            -                                            );
            -                                        }
            -                                        debug_assert!(
            -                                            false,
            -                                            "Failed to get path parent for {:?}.",
            -                                            normalized.path()
            -                                        );
            +        println!("  already inited={}", path.canonicalized.get().is_some());
            +        let res = path.canonicalized.get_or_init(|| {
            +            path.canonicalizing.store(tid, Ordering::Release);
            +
            +            let res = path.parent().map_or_else(
            +                || {
            +                    println!("  calling normalize_root");
            +                    Ok(path.normalize_root(self))
            +                },
            +                |parent| {
            +                    println!("  canonicalizing parent");
            +                    self.canonicalize_impl(parent).and_then(|parent_canonical| {
            +                        println!("  parent_canonical.path={:?}", parent_canonical.path);
            +                        let normalized = parent_canonical
            +                            .normalize_with(path.path().strip_prefix(parent.path()).unwrap(), self);
            +                        println!("  normalized.path={:?}", normalized.path);
            +
            +                        if self.fs.symlink_metadata(path.path()).is_ok_and(|m| m.is_symlink) {
            +                            println!("  path is symlink");
            +                            match self.fs.read_link(normalized.path()) {
            +                                Ok(link) => {
            +                                    if link.is_absolute() {
            +                                        return self
            +                                            .canonicalize_impl(&self.value(&link.normalize()));
            +                                    } else if let Some(dir) = normalized.parent() {
            +                                        // Symlink is relative `../../foo.js`, use the path directory
            +                                        // to resolve this symlink.
            +                                        return self
            +                                            .canonicalize_impl(&dir.normalize_with(&link, self));
                                                 }
            -                                    Err(ResolveError::PathNotSupported(_)) => {
            -                                        // No need to follow symlink if the target path cannot be imported in NodeJS.
            -                                        // Note that per current implementation, if there is a symlink chain, like
            -                                        //      A --> B --> C
            -                                        // we won't follow the symlink as long as try_read_link(B) is None,
            -                                        // regardless of whether C is a valid path for NodeJS. This is a corner case.
            -                                        // We may need to revisit this in the future.
            -                                    }
            -                                    Err(e) => return Err(e),
            +                                    debug_assert!(
            +                                        false,
            +                                        "Failed to get path parent for {:?}.",
            +                                        normalized.path()
            +                                    );
            +                                }
            +                                Err(ResolveError::PathNotSupported(_)) => {
            +                                    // No need to follow symlink if the target path cannot be imported in NodeJS.
            +                                    // Note that per current implementation, if there is a symlink chain, like
            +                                    //      A --> B --> C
            +                                    // we won't follow the symlink as long as try_read_link(B) is None,
            +                                    // regardless of whether C is a valid path for NodeJS. This is a corner case.
            +                                    // We may need to revisit this in the future.
                                             }
            +                                Err(e) => return Err(e),
                                         }
            +                        } else {
            +                            println!("  path is not symlink");
            +                        }

            -                            Ok(normalized)
            -                        })
            -                    },
            -                );
            -
            -                path.canonicalizing.store(0, Ordering::Release);
            -                res
            -            })
            -            .clone()
            +                        Ok(normalized)
            +                    })
            +                },
            +            );
            +
            +            path.canonicalizing.store(0, Ordering::Release);
            +            res
            +        });
            +        println!("  get_or_init returned is_ok={}", res.is_ok());
            +        let res_cloned = res.clone();
            +        println!("clone returned");
            +        return res_cloned;
                 }
             }

            @@ -475,6 +531,7 @@ impl PartialEq for FsCachedPath {

             impl Eq for FsCachedPath {}

            +#[derive(Debug)]
             struct BorrowedCachedPath<'a> {
                 hash: u64,
                 path: &'a Path,
            diff --git a/src/lib.rs b/src/lib.rs
            index 91ab331..c8529e0 100644
            --- a/src/lib.rs
            +++ b/src/lib.rs
            @@ -277,16 +277,29 @@ impl<C: Cache<Cp = FsCachedPath>> ResolverGeneric<C> {
                     specifier: &str,
                     ctx: &mut Ctx,
                 ) -> Result<Resolution<C>, ResolveError> {
            +        println!("resolve_impl({path:?}, {specifier:?}, {ctx:#?})");
                     ctx.with_fully_specified(self.options.fully_specified);

                     let cached_path = if self.options.symlinks {
            -            self.load_realpath(&self.cache.value(path))?
            +            println!("in symlink branch, calling cache.value({path:?})");
            +            let cache_res = self.cache.value(path);
            +            println!("in symlink branch, calling load_realpath(...)");
            +            self.load_realpath(&cache_res)?
                     } else {
                         path.to_path_buf()
                     };

            +        println!("calling cache.value({cached_path:?})");
                     let cached_path = self.cache.value(&cached_path);
            -        let cached_path = self.require(&cached_path, specifier, ctx)?;
            +        println!("calling self.require(...)");
            +        let cached_path = match self.require(&cached_path, specifier, ctx) {
            +            Ok(v) => v,
            +            Err(e) => {
            +                println!("require failed with {e:?}");
            +                return Err(e);
            +            }
            +        };
            +        println!("require succeeded");

                     let path = if self.options.symlinks {
                         self.load_realpath(&cached_path)?


      - run: pnpm run build --target="${RUST_ARCH}-pc-windows-msvc"
        env:
          CARGO_PROFILE_RELEASE_DEBUG_ASSERTIONS: 'true'
          CARGO_PROFILE_RELEASE_OVERFLOW_CHECKS: 'true'
          CARGO_PROFILE_RELEASE_PANIC: unwind
          RUST_ARCH: ${{ (matrix.arch == 'ia32' && 'i686') || 'x86_64' }}
      - run: |
          cat >repro.js <<EOF
          const {ResolverFactory} = require('./napi');
          let resolver = new ResolverFactory({});
          resolver.sync(__dirname, 'x-' + __dirname + '\\\\node_modules\\\\any.js');
          resolver = resolver.cloneWithOptions({});
          resolver.clearCache();
          resolver.sync(__dirname + '\\\\node_modules\\\\foo-bar-foo-bar-fo', 'foo-bar-fo');
          console.log('unexpectedly survived second sync call');
          EOF

      - run: node repro.js
      # - run: pnpm run test
      # - run: for i in {0..100}; do node unrs_repro.js; done
